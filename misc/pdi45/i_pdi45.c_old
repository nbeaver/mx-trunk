/*
 * Name:    i_pdi45.c
 *
 * Purpose: MX driver for Prairie Digital, Inc. Model 45 data acquisition
 *          and control module.
 *
 * Author:  William Lavender
 *
 *--------------------------------------------------------------------------
 *
 * Copyright 1999, 2001, 2003 Illinois Institute of Technology
 *
 * See the file "LICENSE" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <stdio.h>
#include <stdlib.h>

#include "mxconfig.h"
#include "mx_util.h"
#include "mx_record.h"
#include "mx_rs232.h"
#include "i_pdi45.h"

MX_RECORD_FUNCTION_LIST mxi_pdi45_record_function_list = {
	mxi_pdi45_initialize_type,
	mxi_pdi45_create_record_structures,
	mxi_pdi45_finish_record_initialization,
	mxi_pdi45_delete_record,
	NULL,
	mxi_pdi45_read_parms_from_hardware,
	mxi_pdi45_write_parms_to_hardware,
	mxi_pdi45_open,
	mxi_pdi45_close
};

MX_GENERIC_FUNCTION_LIST mxi_pdi45_generic_function_list = {
	NULL
#if 0
	mxi_pdi45_getchar,
	mxi_pdi45_putchar,
	mxi_pdi45_read,
	mxi_pdi45_write,
	mxi_pdi45_input_is_available,
	mxi_pdi45_discard_unread_input,
	mxi_pdi45_discard_unwritten_output
#endif
};

MX_RECORD_FIELD_DEFAULTS mxi_pdi45_record_field_defaults[] = {
	MX_RECORD_STANDARD_FIELDS,
	MXI_PDI45_STANDARD_FIELDS
};

long mxi_pdi45_num_record_fields
		= sizeof( mxi_pdi45_record_field_defaults )
			/ sizeof( mxi_pdi45_record_field_defaults[0] );

MX_RECORD_FIELD_DEFAULTS *mxi_pdi45_rfield_def_ptr
			= &mxi_pdi45_record_field_defaults[0];

MX_EXPORT mx_status_type
mxi_pdi45_initialize_type( long type )
{
	/* Nothing needed here. */

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
mxi_pdi45_create_record_structures( MX_RECORD *record )
{
	const char fname[] = "mxi_pdi45_create_record_structures()";

	MX_GENERIC *generic;
	MX_PDI45 *pdi45;

	/* Allocate memory for the necessary structures. */

	generic = (MX_GENERIC *) malloc( sizeof(MX_GENERIC) );

	if ( generic == (MX_GENERIC *) NULL ) {
		return mx_error( MXE_OUT_OF_MEMORY, fname,
		"Can't allocate memory for MX_GENERIC structure." );
	}

	pdi45 = (MX_PDI45 *) malloc( sizeof(MX_PDI45) );

	if ( pdi45 == (MX_PDI45 *) NULL ) {
		return mx_error( MXE_OUT_OF_MEMORY, fname,
	"Can't allocate memory for MX_PDI45 structure." );
	}

	/* Now set up the necessary pointers. */

	record->record_class_struct = generic;
	record->record_type_struct = pdi45;
	record->class_specific_function_list
				= &mxi_pdi45_generic_function_list;

	generic->record = record;

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
mxi_pdi45_finish_record_initialization( MX_RECORD *record )
{
	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
mxi_pdi45_delete_record( MX_RECORD *record )
{
        if ( record == NULL ) {
                return MX_SUCCESSFUL_RESULT;
        }
        if ( record->record_type_struct != NULL ) {
                free( record->record_type_struct );

                record->record_type_struct = NULL;
        }
        if ( record->record_class_struct != NULL ) {
                free( record->record_class_struct );

                record->record_class_struct = NULL;
        }
        return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
mxi_pdi45_read_parms_from_hardware( MX_RECORD *record )
{
	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
mxi_pdi45_write_parms_to_hardware( MX_RECORD *record )
{
	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
mxi_pdi45_open( MX_RECORD *record )
{
	const char fname[] = "mxi_pdi45_open()";

	MX_PDI45 *pdi45;
	mx_status_type status;

	MX_DEBUG(2, ("mxi_pdi45_open() invoked."));

	if ( record == (MX_RECORD *) NULL ) {
		return mx_error( MXE_NULL_ARGUMENT, fname,
			"MX_RECORD pointer passed is NULL.");
	}

	pdi45 = (MX_PDI45 *) (record->record_class_struct);

	if ( pdi45 == (MX_PDI45 *) NULL ) {
		return mx_error( MXE_CORRUPT_DATA_STRUCTURE, fname,
		"MX_PDI45 pointer for record '%s' is NULL.", record->name);
	}

	status = pdi45_open( pdi45 );

	return status;
}

MX_EXPORT mx_status_type
mxi_pdi45_close( MX_RECORD *record )
{
	const char fname[] = "mxi_pdi45_close()";

	MX_PDI45 *pdi45;
	mx_status_type status;

	MX_DEBUG(2, ("mxi_pdi45_close() invoked."));

	if ( record == (MX_RECORD *) NULL ) {
		return mx_error( MXE_NULL_ARGUMENT, fname,
			"MX_RECORD pointer passed is NULL.");
	}

	pdi45 = (MX_PDI45 *) (record->record_class_struct);

	if ( pdi45 == (MX_PDI45 *) NULL ) {
		return mx_error( MXE_CORRUPT_DATA_STRUCTURE, fname,
		"MX_PDI45 pointer for record '%s' is NULL.", record->name);
	}

	status = pdi45_close( pdi45 );

	return status;
}

/***************************************************************************/

MX_EXPORT mx_status_type
pdi45_open( MX_PDI45 *pdi45 )
{
	const char fname[] = "pdi45_open()";

#if 0
	MX_RS232 *rs232;
#endif

	char response[250];
	char *communication_configuration;
	int exit_loop, length;
	int power_up_clear_needed, four_step_mode;
	int pdi45_error_code;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_open() invoked."));

	exit_loop = FALSE;
	four_step_mode = FALSE;
	power_up_clear_needed = FALSE;
	communication_configuration = NULL;

#if 0
	/* Flush any unread or unwritten characters left over. */

	rs232 = pdi45->rs232;

	status = mx_rs232_discard_unwritten_chars( rs232 );

	if ( status.code != MXE_SUCCESS && status.code != MXE_UNSUPPORTED ) {
		return status;
	}

	status = mx_rs232_discard_unread_chars( rs232 );

	if ( status.code != MXE_SUCCESS ) {
		return status;
	}
#endif

	/* Start out by trying to read the communication configuration. */

	while ( exit_loop == FALSE ) {

		if ( power_up_clear_needed ) {
			status = pdi45_power_up_clear( pdi45 );

			if ( status.code != MXE_SUCCESS )
				return status;
		}

		status = pdi45_write( pdi45, ">00%0B5" );

		if ( status.code != MXE_SUCCESS ) {
			return status;
		}

		/* See what response we got from the PDI 45 */

		status = pdi45_read( pdi45, response, sizeof response );

		if ( status.code != MXE_SUCCESS ) {
			return status;
		}

		switch( response[0] ) {
		default:	/* ===== Illegal response. ===== */

			MX_DEBUG(-2, ("Illegal response char = 0x%x '%c'",
				response[0], response[0]));

			return mx_error( MXE_INTERFACE_IO_ERROR, fname,
"Unexpected response to read communication configuration command = '%s'",
				response );
			break;
	
		case 'N':	/* ===== Error code response. ===== */

			status = pdi45_get_error_code(response,
							&pdi45_error_code);

			if (status.code != MXE_SUCCESS ) {
				return status;
			}

			switch( pdi45_error_code ) {
			default:
				return mx_error(MXE_INTERFACE_IO_ERROR, fname,
	"Unexpected error code %d while trying to connect to the PDI 45.",
					pdi45_error_code);

			case PDI45_ERR_POWER_UP_CLEAR_EXPECTED:
				/* Give up if this is a second try. */

				if ( power_up_clear_needed == TRUE ) {
					return mx_error(
					MXE_INTERFACE_IO_ERROR, fname,
			"Power up clear of the PDI 45 was not successful.");
				}

				power_up_clear_needed = TRUE;
				break;
			}
			break;

		case 'A':	/* ===== Acknowledgement response. ===== */

			power_up_clear_needed = FALSE;

			/* Are we in two step mode or four step mode? */

			length = strlen( response );

			switch( length ) {
			default:
				MX_DEBUG(-2,("Response length = %d", length));

				return mx_error(MXE_INTERFACE_IO_ERROR, fname,
"Unexpected response to read communication configuration command = '%s'",
					response );
				break;

			case 13:
				four_step_mode = FALSE;
				communication_configuration = &response[0];
				break;

			case 7:
				if ( strcmp( response, "A00%0B5" ) != 0 ) {
					return mx_error(
					MXE_INTERFACE_IO_ERROR, fname,
"Unexpected response to read communication configuration command = '%s'",
						response );
				}
				four_step_mode = TRUE;

				/* Now need to execute the command. */

				status = pdi45_write( pdi45, "E" );

				if ( status.code != MXE_SUCCESS ) {
					return status;
				}

				/* Get the response. */

				status = pdi45_read( pdi45, response,
							sizeof response );

				if ( status.code != MXE_SUCCESS ) {
					return status;
				}

				communication_configuration = &response[0];
				break;
			}
			break;
		}

		if ( power_up_clear_needed == TRUE ) {
			exit_loop = FALSE;
		} else {
			exit_loop = TRUE;
		}
	}

	/* Save the four step mode flag. */

	pdi45->four_step_mode = four_step_mode;
				
	/* Now we have the PDI 45 communication configuration information,
	 * so put it in the MX_PDI45 structure.
	 */

	MX_DEBUG(-2, ("PDI45 config = '%s'", communication_configuration));

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_close( MX_PDI45 *pdi45 )
{
	/* Nothing to do here normally, since the PDI 45 hardware
	 * configuration can only be reprogrammed in setup mode.
	 */

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_read( MX_PDI45 *pdi45, char *buffer, int buffer_length )
{
	const char fname[] = "pdi45_read()";

	char c;
	int i;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read() invoked."));

	for ( i = 0; i < (buffer_length - 1) ; i++ ) {
		status = mx_rs232_getchar( pdi45->rs232_record,
						&c, MXF_232_WAIT );

		if ( status.code != MXE_SUCCESS ) {
			/* Make the buffer contents a valid C string
			 * before returning, so that we can at least
			 * see what appeared before the error.
			 */

			buffer[i] = '\0';

			MX_DEBUG(-2, ("pdi45_read() failed.\nbuffer = '%s'",
				buffer));

			MX_DEBUG(-2, ("Failed with status = %ld, c = 0x%x '%c'",
				status.code, c, c));

			return status;
		}

		buffer[i] = c;

		/* Responses from the PDI 45 should be terminated
		 * by the end of string character.
		 */

		if ( c == PDI45_END_OF_STRING ) {
			i++;

			break; 		/* exit the for() loop */
		}
	}

	/* Check to see if the last character was an end of string
	 * and if it is then overwrite it with a NULL.
	 */

	if ( buffer[i-1] != PDI45_END_OF_STRING ) {
		status = mx_error( MXE_INTERFACE_IO_ERROR, fname,
			"Warning: Input buffer overrun." );

		buffer[i] = '\0';
	} else {
		status = MX_SUCCESSFUL_RESULT;

		buffer[i-1] = '\0';
	}

	MX_DEBUG(-2, ("pdi45_read() done\nbuffer = '%s'", buffer));

	return status;
}

MX_EXPORT mx_status_type
pdi45_write( MX_PDI45 *pdi45, char *buffer )
{
	char *ptr;
	char c;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_write() invoked.\nbuffer = '%s'", buffer));

	ptr = &buffer[0];

	while ( *ptr != '\0' ) {
		c = *ptr;

		status = mx_rs232_putchar( pdi45->rs232_record,
						c, MXF_232_WAIT );

		if ( status.code != MXE_SUCCESS )
			return status;

		ptr++;
	}

	/* Was the last character an end of string character?
	 * If not, then send one.
	 */

	if ( *(ptr - 1) != PDI45_END_OF_STRING ) {
		status = mx_rs232_putchar( pdi45->rs232_record,
					PDI45_END_OF_STRING, MXF_232_WAIT );

		if ( status.code != MXE_SUCCESS )
			return status;
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_command( MX_PDI45 *pdi45, char *command, char *response )
{
	const char fname[] = "pdi45_command()";

	char read_buffer[PDI45_COMMAND_LENGTH];
	char write_buffer[PDI45_COMMAND_LENGTH];
	char checksum[4];
	int pdi45_error_code;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_command() invoked."));

	/* Construct checksum field for outgoing PDI45 command. */

	status = pdi45_checksum( pdi45, command, checksum );

	if ( status.code != MXE_SUCCESS ) {
		return status;
	}

	/* Format the command string. */

	sprintf(write_buffer, ">%s%s", command, checksum);

	/* Send the PDI45 command. */

	status = pdi45_write( pdi45, write_buffer );

	if ( status.code != MXE_SUCCESS ) {
		return status;
	}

	/* Read the response to the command. */

	status = pdi45_read( pdi45, read_buffer, sizeof(read_buffer) );

	if ( status.code != MXE_SUCCESS )
		return status;

	/* Check the checksum of the response. */

	status = pdi45_check_checksum( read_buffer );

	if ( status.code != MXE_SUCCESS )
		return status;

	/* Was the response an error code? */

	switch( read_buffer[0] ) {
	case 'A':
		/* Copy the response to the output variable if desired. */

		if ( response != NULL ) {
			strcpy( response, read_buffer );
		}

		return MX_SUCCESSFUL_RESULT;
		break;

	case 'N':
		status = pdi45_get_error_code(read_buffer, &pdi45_error_code);

		if ( status.code != MXE_SUCCESS )
			return status;

		/* Perhaps add another argument to pdi45_command() to
		 * return the value of pdi45_error_code in.
		 */

		return mx_error( MXE_INTERFACE_ACTION_FAILED, fname,
		"PDI 45 command '%s' returned an error code of %d",
			command, pdi45_error_code );
		break;

	default:
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unexpected response to command '%s'.  Response = '%s'.",
			write_buffer, read_buffer );
		break;
	}

#if 1		/* The SunOS acc compiler doesn't like this line being here.
		 * It emits a warning to the effect
		 *    "warning: statement not reached"
		 */

	return MX_SUCCESSFUL_RESULT;
#endif
}

MX_EXPORT mx_status_type
pdi45_checksum( MX_PDI45 *pdi45, char *command, char *checksum )
{
	int i, length, value;

	MX_DEBUG(-2, ("pdi45_checksum() invoked."));

	length = strlen( command );

	/* Add up the character values. */

	value = 0;

	for ( i = 0; i < length; i++ ) {
		value += command[i];
	}

	/* Only interested in the low order 8 bits. */

	value %= 256;

	/* Convert to a character string. */

	sprintf( checksum, "%02X", value );

	MX_DEBUG(-2, ("checksum = '%s'", checksum));

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_check_checksum( char *response )
{
	const char fname[] = "pdi45_check_checksum()";

	int i, num_chars, num_items;
	int returned_checksum, computed_checksum;
	char *ptr;

	if ( response[0] != 'A' ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"The string '%s' is not a valid PDI Model 45 response.",
			response );
	}

	num_chars = strlen( response );

	if ( response[num_chars - 1] == '\r' ) {
		response[num_chars - 1] = '\0';

		num_chars -= 1;
	}

	/* Leave out the checksum field. */

	num_chars -= 2;

	if ( num_chars <= 0 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
"The string '%s' is not long enough to be a valid PDI Model 45 response.",
			response );
	}

	/* Parse the returned checksum. */
		
	ptr = response + num_chars;

	num_items = sscanf( ptr, "%2x", &returned_checksum );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
	"The checksum field '%c%c' has non-hexadecimal characters in it.",
			ptr[0], ptr[1] );
	}

	/* Compute our own version of the checksum. */

	computed_checksum = 0;

	/* Skip over the 'A' at the beginning. */

	for ( i = 1; i < num_chars; i++ ) {
		computed_checksum += response[i];
	}

	MX_DEBUG(-2, ("computed checksum = 0x%X, returned checksum = 0x%X",
		computed_checksum, returned_checksum));

	if ( computed_checksum == returned_checksum ) {
		return MX_SUCCESSFUL_RESULT;
	} else {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
	"Checksum error: computed checksum = 0x%X, returned checksum = 0x%X",
			computed_checksum, returned_checksum );
	}
}

MX_EXPORT mx_status_type
pdi45_debug_mode( MX_PDI45 *pdi45, int mode )
{
	MX_DEBUG(-2, ("pdi45_debug_mode() invoked."));

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_get_error_code( char *buffer, int *error_code )
{
	const char fname[] = "pdi45_get_error_code()";

	char error_string[3];
	int num_items, code;

	MX_DEBUG(-2, ("pdi45_get_error_code() invoked."));

	if (( buffer[0] != 'N' ) || ( buffer[3] != '\r' )) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"'%s' is not a valid PDI Model 45 error code.", buffer );
	}

	error_string[0] = buffer[1];
	error_string[1] = buffer[2];
	error_string[2] = '\0';

	num_items = sscanf( error_string, "%x", &code );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"The error code '%s' has non-hexadecimal characters in it.",
			error_string );
	}

	if ( code > 0x07 ) {
		if ( code != 0x10 ) {
			return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Error code 0x%X is not a valid PDI Model 45 error code.",
				code );
		}
	}

	*error_code = code;

	return MX_SUCCESSFUL_RESULT;
}

/***** Commands allowed only in setup mode. *****/

/* --- Not all setup mode commands are supported yet. --- */

MX_EXPORT mx_status_type
pdi45_set_digital_io_type( MX_PDI45 *pdi45, int dline, int io_type, int dtype )
{
	const char fname[] = "pdi45_set_digital_io_type()";

	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_set_digital_io_type() invoked."));

	switch( io_type ) {
	case PDI45_INPUT_TYPE:
		/* Check for illegal configurations. */

		if ( dtype == 1 || dtype == 2 ) {
			if ( dline != 0 && dline != 1 )	 {
				return mx_error( MXE_ILLEGAL_ARGUMENT, fname,
		"Input type %d is only allowed for digital lines 0 and 1.",
					dtype );
			}
		} else
		if ( dtype >= 3 && dtype <= 10 ) {
			if ( dline != 4 && dline != 5 ) {
				return mx_error( MXE_ILLEGAL_ARGUMENT, fname,
		"Input type %d is only allowed for digital lines 4 and 5.",
					dtype );
			}
		} else
		if ( dtype == 0 || dtype == 11 || dtype == 12 ) {
			/* Do nothing. */

		} else {
			return mx_error( MXE_ILLEGAL_ARGUMENT, fname,
			"Unrecognized digital input type %d.", dtype );
		}

		/* Define this line to be an input line. */

		sprintf( command, "00H%1X", (1 << dline) );

		status = pdi45_command( pdi45, command, NULL );

		if ( status.code != MXE_SUCCESS )
			return status;

		/* Define the type of the line. */

		sprintf( command, "00!100%02X%02X", ( 1 << dline ), dtype );

		status = pdi45_command( pdi45, command, NULL );

		if ( status.code != MXE_SUCCESS )
			return status;

		break;

	case PDI45_OUTPUT_TYPE:

		/* Define this line to be an output line. */

		sprintf( command, "00I%1X", (1 << dline) );

		status = pdi45_command( pdi45, command, NULL );

		if ( status.code != MXE_SUCCESS )
			return status;

		/* Define the type of the line. */

		sprintf( command, "00!100%02X%02X", ( 1 << dline ), dtype );

		status = pdi45_command( pdi45, command, NULL );

		if ( status.code != MXE_SUCCESS )
			return status;

		break;

	default:
		return mx_error( MXE_ILLEGAL_ARGUMENT, fname,
			"Illegal I/O type %d.", io_type );
		break;
	}

	return MX_SUCCESSFUL_RESULT;
}

/***** Commands allowed in both setup mode and normal mode. *****/

MX_EXPORT mx_status_type
pdi45_read_output_timer( MX_PDI45 *pdi45,
				int dline, int *timer_on, int *hex_value )
{
	const char fname[] = "pdi45_read_output_timer()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items;
	mx_status_type status;

	sprintf( command, "00*000%02X", (1 << dline) );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 1, "%1X%4X", timer_on, hex_value );

	if ( num_items != 2 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unparseable response '%s' to command '%s'",
			response, command );
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_set_output_timer( MX_PDI45 *pdi45, int dline, int hex_value )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_set_timer() invoked."));

	sprintf( command, "00*100%02X%04X", (1 << dline), hex_value );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

/***** Commands allowed only in normal mode. *****/

MX_EXPORT mx_status_type
pdi45_read_communication_config( MX_PDI45 *pdi45 )
{
	const char fname[] = "pdi45_read_communication_config()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	char buffer[5];
	int hex_value, num_items;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_communication_config() invoked."));

	strcpy( command, "00%0" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	/* Read module version. */

	strncpy( buffer, response + 1, 2 );

	num_items = sscanf( buffer, "%x", &hex_value );
	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable module version in response '%s'.",
			response );
	}

	pdi45->version = hex_value;

	/* Read first comm parameter digit. */

	strncpy( buffer, response + 3, 1 );

	num_items = sscanf( buffer, "%x", &hex_value );
	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable comm parameter word in response '%s'.",
			response );
	}

	pdi45->data_bits      = hex_value & 0x1;
	pdi45->parity         = hex_value & 0x6;
	pdi45->four_step_mode = hex_value & 0x8;

	/* Read second comm parameter digit. */

	strncpy( buffer, response + 4, 1 );

	num_items = sscanf( buffer, "%x", &hex_value );
	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable comm parameter word in response '%s'.",
			response );
	}

	pdi45->speed = hex_value;

	/* Get the turn around delay setting. */

	strncpy( buffer, response + 5, 2 );

	num_items = sscanf( buffer, "%x", &hex_value );
	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable turn around delay setting in response '%s'.",
			response );
	}

	pdi45->turn_around_delay = hex_value;

	/* Get the communication timer setting. */

	strncpy( buffer, response + 7, 4 );

	num_items = sscanf( buffer, "%x", &hex_value );
	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable communication timer setting in response '%s'.",
			response );
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_power_up_clear( MX_PDI45 *pdi45 )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_power_up_clear() invoked."));

	strcpy( command, "00A" );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_reset( MX_PDI45 *pdi45 )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_power_up_clear() invoked."));

	strcpy( command, "00B" );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_digital_io_types( MX_PDI45 *pdi45 )
{
	const char fname[] = "pdi45_read_digital_io_types()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	char buffer[3];
	int i, num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_digital_io_types() invoked."));

	strcpy( command, "00!0" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	for ( i = 0; i < PDI45_NUM_DIGITAL_CHANNELS; i++ ) {
		strncpy( buffer, response + 31 - 2 * i, 2 );

		num_items = sscanf( buffer, "%x", &hex_value );
		if ( num_items != 1 ) {
			return mx_error( MXE_INTERFACE_IO_ERROR, fname,
			"Unrecognizable digital io type in response '%s'.",
				buffer );
		}
		pdi45->io_type[i] = hex_value;
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_read_digital_power_up_levels( MX_PDI45 *pdi45,
			int *io_directions, int *power_up_levels )
{
	const char fname[] = "pdi45_read_digital_power_up_levels()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_digital_power_up_levels() invoked."));

	strcpy( command, "00#0" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf(response, "%4X%4X", io_directions, power_up_levels);

	if ( num_items != 2 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable digital power up levels in response '%s'.",
			response );
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_set_digital_on( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_set_digital_on() invoked."));

	sprintf( command, "00K%02X", (1 << dline) );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_set_digital_off( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_set_digital_off() invoked."));

	sprintf( command, "00L%02X", (1 << dline) );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_all_digital_io_levels( MX_PDI45 *pdi45, int *value )
{
	const char fname[] = "pdi45_read_all_digital_io_levels()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_all_digital_io_levels() invoked."));

	strcpy( command, "00M" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 3, "%2X", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable digital I/O levels in response '%s'.",
			response );
	}

	*value = hex_value;

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_digital_io_level( MX_PDI45 *pdi45, int dline, int *value )
{
	int all_values;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_digital_io_level() invoked."));

	status = pdi45_read_all_digital_io_levels( pdi45, &all_values );

	if ( status.code != MXE_SUCCESS )
		return status;

	all_values &= (1 << dline);

	if ( all_values != 0 ) {
		*value = 1;
	} else {
		*value = 0;
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_read_all_latches( MX_PDI45 *pdi45, int *value )
{
	const char fname[] = "pdi45_read_all_latches()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_all_latches() invoked."));

	strcpy( command, "00Q" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 3, "%2X", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable latch values in response '%s'.",
			response );
	}

	*value = hex_value;

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_latch( MX_PDI45 *pdi45, int dline, int *value )
{
	int all_values;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_latch() invoked."));

	status = pdi45_read_all_latches( pdi45, &all_values );

	if ( status.code != MXE_SUCCESS )
		return status;

	all_values &= (1 << dline);

	if ( all_values != 0 ) {
		*value = 1;
	} else {
		*value = 0;
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_read_and_clear_all_latches( MX_PDI45 *pdi45, int *value )
{
	const char fname[] = "pdi45_read_and_clear_all_latches()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_and_clear_all_latches() invoked."));

	strcpy( command, "00RFF" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 3, "%2x", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable latch values in response '%s'.",
			response );
	}

	*value = hex_value;

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_and_clear_latch( MX_PDI45 *pdi45, int dline, int *value )
{
	const char fname[] = "pdi45_read_and_clear_latch()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, all_values;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_and_clear_latche() invoked."));

	sprintf( command, "00R%02X", (1 << dline) );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 3, "%2x", &all_values );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable latch value in response '%s'.",
			response );
	}

	all_values &= (1 << dline);

	if ( all_values != 0 ) {
		*value = 1;
	} else {
		*value = 0;
	}

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_clear_all_latches( MX_PDI45 *pdi45 )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_clear_all_latches() invoked."));

	strcpy( command, "00SFF" );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_clear_latch( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_clear_latch() invoked."));

	sprintf( command, "00S%02X", 1 << dline );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_enable_counter( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_enable_counter() invoked."));

	sprintf( command, "00U%02X", 1 << dline );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_disable_counter( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_disable_counter() invoked."));

	sprintf( command, "00V%02X", 1 << dline );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_counter( MX_PDI45 *pdi45, int dline, int *count )
{
	const char fname[] = "pdi45_read_counter()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	char *ptr;
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_counter() invoked."));

	sprintf( command, "00W%02X", 1 << dline );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	ptr = response + 1;	/* Skip over the A. */

	/* Check to see if this line is not defined as
	 * a counter.
	 */

	if ( strncmp( ptr, "????", 4 ) == 0 ) {
		return mx_error( MXE_UNSUPPORTED, fname,
		"Unsupported counter number %d.", dline );
	}

	num_items = sscanf( ptr, "%4x", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable counter value in response '%s'.", ptr );
	}

	*count = hex_value;

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_and_clear_counter( MX_PDI45 *pdi45, int dline, int *count )
{
	const char fname[] = "pdi45_read_and_clear_counter()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	char *ptr;
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_and_clear_counter() invoked."));

	sprintf( command, "00X%02X", 1 << dline );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	ptr = response + 1;	/* Skip over the A. */

	/* Check to see if this line is not defined as
	 * a counter.
	 */

	if ( strncmp( ptr, "????", 4 ) == 0 ) {
		return mx_error( MXE_UNSUPPORTED, fname,
		"Unsupported counter number %d.", dline );
	}

	num_items = sscanf( ptr, "%4x", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable counter value in response '%s'.", ptr );
	}

	*count = hex_value;

	return status;
}

MX_EXPORT mx_status_type
pdi45_clear_counter( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_clear_counter() invoked."));

	sprintf( command, "00Y%02X", 1 << dline );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_retrigger_time_delay( MX_PDI45 *pdi45, int dline )
{
	char command[PDI45_COMMAND_LENGTH];
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_retrigger_time_delay() invoked."));

	sprintf( command, "00h%02X", 1 << dline );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_set_analog_output( MX_PDI45 *pdi45, int channel, double voltage )
{
	char command[PDI45_COMMAND_LENGTH];
	int hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_set_analog_output() invoked."));

	hex_value = (int) ( voltage / (5.0 / 256.0) );

	sprintf( command, "FFJ000%01X%03X", (1 << channel), hex_value );

	status = pdi45_command( pdi45, command, NULL );

	return status;
}

MX_EXPORT mx_status_type
pdi45_read_analog_output( MX_PDI45 *pdi45, int channel, double *voltage )
{
	const char fname[] = "pdi45_read_analog_output()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_analog_output() invoked."));

	sprintf( command, "FFK%02X", 1 << channel );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 2, "%2x", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable analog output value in response '%s'.",
			response );
	}

	*voltage = ( 5.0 / 256.0 ) * (double) hex_value;

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_read_analog_input( MX_PDI45 *pdi45, int channel, double *voltage )
{
	const char fname[] = "pdi45_read_analog_input()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_analog_input() invoked."));

	sprintf( command, "FFL%02X", 1 << channel );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 3, "%2x", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
		"Unrecognizable analog input value in response '%s'.",
			response );
	}

	*voltage = ( 5.0 / 256.0 ) * (double) hex_value;

	return MX_SUCCESSFUL_RESULT;
}

MX_EXPORT mx_status_type
pdi45_read_analog_output_power_up_levels( MX_PDI45 *pdi45,
		double *channel0_output, double *channel1_output )
{
	const char fname[] = "pdi45_read_analog_output_power_up_levels()";

	char command[PDI45_COMMAND_LENGTH];
	char response[PDI45_COMMAND_LENGTH];
	int num_items, hex_value;
	mx_status_type status;

	MX_DEBUG(-2, ("pdi45_read_analog_output_power_up_levels() invoked."));

	strcpy( command, "FF&0" );

	status = pdi45_command( pdi45, command, response );

	if ( status.code != MXE_SUCCESS )
		return status;

	num_items = sscanf( response + 1, "%03X", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
	"Unrecognizable analog output power up level 0 in response '%s'.",
			response );
	}

	*channel0_output = ( 5.0 / 256.0 ) * (double) hex_value;

	num_items = sscanf( response + 4, "%03X", &hex_value );

	if ( num_items != 1 ) {
		return mx_error( MXE_INTERFACE_IO_ERROR, fname,
	"Unrecognizable analog output power up level 1 in response '%s'.",
			response );
	}

	*channel1_output = ( 5.0 / 256.0 ) * (double) hex_value;

	return MX_SUCCESSFUL_RESULT;
}

